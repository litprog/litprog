# Introduction to LitProg

LitProg is a [literate programming][ref_wiki_litprog] tool which 

 1. uses [markdown][ref_wiki_markdown] files as input,
 2. generates code files using fenced blocks,
 3. generates documentation in HTML and PDF formats.

```bob
  +-------------------+
 ++                   |\      .-----.
 || lit/11_intro.md   +-+    /      |
 || lit/12_test.md      |   /       V
 || lit/13_impl.md      *--'  .-----o-----.
 ||                     |     |  LitProg  |
 |+--------------------++     '---*---*---'
 +---------------------+          |   |
             .--------------------'   |
             V                        V
  +----------+----+     +-------------+-----+
 ++               |\   ++                   |\
 || src/code.py   +-+  || doc/11_intro.pdf  +-+
 || src/logic.js    |  || doc/11_intro.html   |
 || src/data.json   |  || doc/12_test.html    |
 ||                 |  ||                     |
 |+----------------++  |+--------------------++
 +-----------------+   +---------------------+
```

## LitProg by Example

Much has been claimed about the benefits of [Literate Programming][ref_knuthweb]. Instead of repeating what has been said better elsewhere, I will focus here on demonstrating by example.

```python
def fib(n: int) -> int:
    return n if n < 2 else fib(n - 1) + fib(n - 2)
```

```python
# lpsession: python3
# <[ def fib(n: int) -> int: ]>

def run_fib():
    for i in range(10):
        print("fib({}) == {}".format(i, fib(i)))

run_fib()
```

```python
# lpwrapper: timeit
import time

t0 = time.time()

# lpblock

dur = (time.time() - t0) * 1000
print(f"{:9.3f}ms")
```

```python
# lpwrapper: memo($wrapped)

_cache = {}

def memo(fn: Callable[[int], int]) -> Callable[[int], int]:
    if n not in _cache:
        _cache[n] = $wrapped(n)
    return _cache[n]
```

```python
# lpsession: python
# lpwrap: timeit(memo(fib))
```

The above example demonstrates

 1. code composition
 2. code execution
 3. output capture
 4. custom rendering

LitProg is more than just documentation with interspersed code. By capturing output as the program is being generated, you can write an exposition for the reader, which demonstrates the behaviour and correctnes of your program. 

TODO: most bare bones explanation of what LitProg does and examples
LitProg parses markdown files, extracts program code from fenced code blocks, weaves together a program, validates that program,   HTML,  and 

## A More Complete Picture

```bob
   +-----------------.
  ++                  \     
  || "lit/...md"       .     .-------.
  ||                   |    /        V
  ||                   *---'   .-----o-----.
  ||                   |       |  LitProg  |
  |+------------------++       '---*---*---'
  +-------------------+            |   | 
              .--------------------'   |
              V                        V
   +----------+--.     +---------------+---.
  ++              \   ++                    \
  || "src/code.py" .  || "doc/11_intro.html" .
  || "src/code.js" |  || "doc/11_intro.pdf"  |
  || "src/code.go" |  || "doc/12_test.html"  |
  || ...           |  || ...                 |
  |+--------------++  |+--------------------++
  +---------------+   +---------------------+
```

## The Promise of LitProg

 1. is a true Literate Programming tool[^litprog_vs_annotated_src],
 2. is language agnostic[^languages_caveat],
 3. has a flexible build system[^make_caveat],
 4. is not a silver bullet.

A literate program is written, first and foremost, to be understood by people and not merely to be valid input for a compiler or interpreter.

Compared to [traditional Literate Programming tools][ref_lpcom_tools], LitProg leans heavier toward ease of authoring and compromises customization of document layout and typesetting. Programmers and writers can focus more on their ideas and less on . The generated documentation serves its purpose, is good enough to serve the purpose of being 1. accessible to anybody, without having to install an editor, IDE, compiler, VCS, 2. searchable and 3. giving new developers a highmaking code comprehensible to new developers at a high level.

With the proliferation of Markdown, programmers are already using in the small the same format as LitProg. In their issue trackers, chat systems, blog articles and interactive notebooks, [Github Flavored Markdown][ref_gfm] (GFM) has all but become a standard. LitProg expands this approach of using Markdown from comments and documentation to using markdown to generate the programs themselves.



Readers of HTML/PDF documents generated by LitProg should be convinced that

 1. The document is the whole program.
 2. The document only exists, because it is internally consistent.
 
TODO: better wording. It's really only as consistent as it declares itself to be. 


## Glossary

- [Input] Source Files: Markdown based inputs
- [Output] Code Files: An artifact generated from fenced code blocks
- [Output] Documents: HTML or PDF files



`litprog` parses markdown and generates outputs in these
formats:

 1. `src`: Source code files, from code blocks
 2. `doc`: Static HTML files
 3. `pdf`: PDF files (in A4, Letter, Booklet)

It supports the following markdown extensions

 - Footnotes
 - Paragraph with CSS class or HTML node type (admonitions, aside)
 - Diagrams using aafigure
 - Tables
 - Syntax Highlighting using pygments
 - Hyperlinked Source Code (where possible)
 - Math support somehow using MathJax

[ref_wiki_litprog]: https://en.wikipedia.org/wiki/Literate_programming

[ref_lpcom_tools]: http://www.literateprogramming.com/tools.html

[ref_wiki_markdown]: https://en.wikipedia.org/wiki/Markdown

[ref_gfm]: https://github.github.com/gfm/

[knuthweb]: http://www.literateprogramming.com/knuthweb.pdf

[^make_caveat]: No, LitProg is not a replacement for make. I'm well aware of make and honestly I love it to bits. However, since output generated earlier phases of a LitProg build can be used by later phases (for example test results can be shown in output documents), it makes sense to have an integrated build system.

[^languages_caveat]: Any language as long as it uses text based files (i.e. it won't work with [scratch](https://scratch.mit.edu/).

[^litprog_vs_annotated_src]: Many existing markdown based literate programming tools are simply annotation tools for source code, often mapping 1:1 from a markdown file to compiled file with source code. This is fine as far as it goes, but it leaves much less freedom to form a narrative that makes most sens for a reader.

