# LitProg - Human Readable Code

```yaml
lptype: meta
title: LitProg
subtitle: Human Readable Code
language: en
authors: [
    "Manuel Barkhau",
]
```

[TOC]

    Der Mensch ist doch ein Augentier,
    nur schöne Dinge wünsch' ich mir.
        – ~~Goethe~~Rammstein


LitProg is a markdown based literate programming tool which can be used to produce code in any[^languages_caveat] programming language. The main idea of literate programming is that the author of a program should communicate primarilly with a human reader and only secondarilly with the machine.

## Costs and Benefits

Literate programming is not a silver bullet, rather it involves a tradeoff which is very similar to automated testing. There is a higher up-front investment which can pay off over time. For short lived one-off projects it may not make sense.

In the case of automated testing, instead of just doing manual testing during development, the programmer write tests which can be run later to reduce the chance that something has broken after new changes are introduced.

In the case of literate programming, technical documentation is written which explains the intent and high level abstractions of the programmer, which cannot be easilly read just from reading the code. This makes it easier for programmers who are unfamiliar with the code to find their way around the codebase and more confidently make changes.

### Visibility

With automated testing, when using a continuous integration environment, members of the project who are not intimately involved in the details of the code-base can gain some insight into the health of the codebase. Programmers who diligently write tests with high coverage can keep themselves honest and the temptation to cut corners is either kept in check or at the very least exposed. If coverage goes down, if builds are failing and if deployments are happening anyway, then all of this may be justified in the context of a project, but it is a sure sign of degeneration in the standards of the project and may reduce the long-run viability of the project.

Literate programming offers a similar kind of exposure. Programmers who express the intent, the abstractions, the work-arounds and the trade-offs in plain english, who express ideas that are not expressed in the code, will keep themselves more honest as they can assume that their peers will not simply gloss over an undocumented and cryptic part of the codebase. If they simply hack together some code and only half understand what it's actually doing, then the lack of or incoherence of documentation will more readilly expose the degraded health and long-run viability of the project.

### Narrative Order vs Program Order

In terms of code, a definition usually has to preceed its usage. For narrative purposes it may be more appropriate to start with foundational datastructures and high level logic, assuming some prior knowledge about programming convetions, before proceeding to how everything fits together. Often it may be more appropriate to start by looking at code that uses an api and then go on to show how the api is implemented.

When a reader is reading your text, they are building up a context in their mind. If a new concept is introduced to them, it should be understandable to them either based example code which demonstrates how to use it and/or based on definitions and concepts that closely preceeded the introduction of the new concept or are known because they well established. Taken to the extreem, defintions would always preceed their usage and the topics of actual interest to a reader would only be introduced after pages and pages of boilerplate.


## MVP

The initial implementation of LitProg is the bare bones minimum needed to start dogfooding the program itself. The initial goal is to

 1. Have an existing `litprog` command that accepts markdown files as inputs.
 2. Compiles python files in a temporary directory.
 3. Executes tests againts the compiled files and aborts if tests fail.
 4. Installs the new version of the command if the tests pass.

For now we will completely ignore the output as pdf/html tables, footnotes,
images or anything else.

Of course we have a chicken and egg problem here, so to bootstrap the program the python files will have to be implemented in a non LitProg form. For development the easiest python files to work are the ones in the `src/` directory. Using `source activate` and running `pip install .` will install the `litprog` command, which will use code from the `src/` directory. As soon as possible the program should be self hosted.

### The `litprog` Module

All generated code is written to `src/litprog/`, starting with `src/litprog/__init__.py`.

```yaml
filepath: "src/litprog/__init__.py"
inputs  : [
  "license_header_boilerplate",
  "dunder_version",
]
```

The file starts with some legal boilerplate. I honestly can't say what legal relevance of this is, probably it's mostly just ceremonial.

```python
# lpid = license_header_boilerplate
# This file is part of the litprog project
# https://gitlab.com/mbarkhau/litprog
#
# Copyright (c) 2019 Manuel Barkhau (mbarkhau@gmail.com) - MIT License
# SPDX-License-Identifier: MIT
```

```python
# lpid = dunder_version

__version__ = "v201901.0001-alpha"
```

Each module has a module level logger named `log`.

```python
# lpid = module_logger
import logging

log = logging.getLogger(__name__)
```


### Code Conventions

Across the implementation of LitProg there are commonly used aliases for imported modules. In general, the plain `import x` or `import longlib as ll` imports are preferred over `from x import y` so that usage code always includes the context from where they came.

```python
# lpid = common.imports
import typing as typ
import pathlib2 as pl

Paths = typ.Iterable[pl.Path]
```

Since the reader may not have access to the output files and be able to look at all symbols that have been imported into a module, it is better to establish ideoms/conventions about imported modules and have fully qualified references to the attributes of a module, rather than relying on those attributes having been imported and injected into the scope of the current module.

## Glossary

- [Input] Source Files: Markdown based inputs
- [Output] Code Files: An artifact generated from fenced code blocks
- [Output] Documents: HTML or PDF files

## The Goal

There are various levels at which the reader of a literate program will want to understand it, but each of them should trust that the fact that they are viewing a document meands that it conceptually coherent. This is to say, that if the document contains assertions about how it works, then the existence of the document is a testament to the fact that these assertions are true.

If the following code were to fail, the output document would have programatically generatiod visual indication that this was the case.

```yaml
lpid   : demo
lptype : session
command: python3
timeout: 1
echo   : False     # output
term   : True
expected_exit_code: 1
```

```python
# lpid = demo
assert True
```

```python
# lpid = demo
# This code block inherits the LitProg declarations of
# the previous block. In this case it is a continuation of the previous
# "validation" session.
print(1 + 1)
assert False          # The captured output should be an error
```

In order to make integration with existing tools easy and so that LitProg is language agnostic, the macro and plugin system works strictly with text, and does not do any ast/parsing of code blocks. The exception to this is LitProg metadata in the form of code block options.

- `litprog` declarations for code blocks use language specific comment syntax.
  In other words, a LitProg declaration in a python code block the first line
  would start with `# litprog` and in a c++ code block the code the first line
  would start with `// litprog`. This choice was made

## Compile/Build Phases

Some of the considerations that go into what the phases of the compiler do
are

- Plugins/Libraries that do pre- or post-processing and are only referenced.
  Some plugins might be, spell checker, readability score generator, and
  linters.
- We want to be able to integrate code formatters, in other words feed the
  output of a command which takes a fenced code block as input and feeds it
  back into the initial fenced code block.
- To reduce boilerplate, we want to have macros. But other than for
  demonstration of what the macro does, we don't want the code generated by
  them to be in the pdf files (maybe in the html files, but only if it is
  hidden by default).
- LitProg is a build system and the declaration of output files should allow
  for caching/reuse of build artifacts. TODO: investigate `redo` which is
  supposidly a nicer version of `make`.

To produce a program

 0. Run macro definition code blocks.
 1. Run macros to produce intermediate markdown.
 2. Compile code artifacts to tmp directory.
 3. Run interactive sessions and capture outputs.
 4. Produce code artifacts.
 5. Produce intermediate html artifacts from original markdown.
 6. Extend intermediate html artifacts with captured outputs.
 7. Extend intermediate html by running plugins, for example to add anchor tags that enable jump to definition.
 8. Produce pdf artifacts from html.


### Package Metadata


```yaml
filepath: "tmp_setup.py"
inputs  : [
  "license_header_boilerplate",
]
```


[^click_lib_ref]: https://click.palletsprojects.com

[^languages_caveat]: Any language as long as its code is stored in text based files. This is almost all languages, but LitProg won't work with something like scratch.
