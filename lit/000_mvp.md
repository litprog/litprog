# LitProg - Make Code Readable


[TOC]

    Der Mensch ist doch ein Augentier,
    nur schöne Dinge wünsch' ich mir.
        – ~~Goethe~~Rammstein


LitProg is a markdown based literate programming tool which is compatible with any[^languages_caveat] programming language. The main idea of literate programming is that the author of a program should communicate primarilly with human readers and secondarilly to computers.

## Costs and Benefits

Literate programming is not a silver bullet, rather it involves a tradeoff which is very similar to automated testing. There is a higher up-front investment which can pay off over time. For short lived one-off projects it may not make sense.

In the case of automated testing, instead of just doing manual testing during development, the programmer write tests which can be run later to reduce the chance that something has broken after new changes are introduced.

In the case of literate programming, technical documentation is written which explains the intent and high level abstractions of the programmer, which cannot be easilly read just from reading the code. This makes it easier for programmers who are unfamiliar with the code to find their way around the codebase and more confidently make changes.

### Visibility

With automated testing, when using a continuous integration environment, members of the project who are not intimately involved in the details of the code-base can gain some insight into the health of the codebase. Programmers who diligently write tests with high coverage can keep themselves honest and the temptation to cut corners is either kept in check or at the very least exposed. If coverage goes down, if builds are failing and if deployments are happening anyway, then all of this may be justified in the context of a project, but it is a sure sign of degeneration in the standards of the project and may reduce the long-run viability of the project.

Literate programming offers a similar kind of exposure. Programmers who express the intent, the abstractions, the work-arounds and the trade-offs in plain english, who express ideas that are not expressed in the code, will keep themselves more honest as they can assume that their peers will not simply gloss over an undocumented and cryptic part of the codebase. If they simply hack together some code and only half understand what it's actually doing, then the lack of or incoherence of documentation will more readilly expose the degraded health and long-run viability of the project.

### Narative Order vs Program Order

In terms of code, a definition usually has to preceed its usage. For narrative purposes it may be more appropriate to start with foundational datastructures and high level logic, assuming some prior knowledge about programming convetions, before proceeding to how everything fits together. Often it may be more appropriate to start by looking at code that uses an api and then go on to show how the api is implemented.

## MVP

The initial implementation[^1] of LitProg is the bare bones minimum needed to start dogfooding the program itself. The initial goal is to

 1. Have an existing `litprog` command that accepts markdown files as inputs.
 2. Compiles python files in a temporary directory.
 3. Executes tests againts the compiled files and aborts if tests fail.
 4. Installs the new version of the command if the tests pass.

For now we will completely ignore the output as pdf/html tables, footnotes,
images or anything else.

Of course we have a chicken and egg problem here, so to bootstrap the program the python files will have to be implemented in a non LitProg form. For development the easiest python files to work are the ones in the `src/` directory. Using `source activate` and running `pip install .` will install the `litprog` command, which will use code from the `src/` directory. As soon as possible the program should be self hosted.

### The `litprog` Module

All generated code is written to `src/litprog/`, starting with `src/litprog/__init__.py`.

```yaml
lptype: out_file
lpid: litprog_init_py
filepath : "src/litprog/tmp__init__.py"
inputs : [
  "license_header_boilerplate",
  "dunder_version",
]
```

The file starts with some legal boilerplate. I honestly can't say what legal relevance of this is, probably it's mostly just ceremonial.

```python
# lpid = license_header_boilerplate
# This file is part of the litprog project
# https://gitlab.com/mbarkhau/litprog
#
# Copyright (c) 2019 Manuel Barkhau (mbarkhau@gmail.com) - MIT License
# SPDX-License-Identifier: MIT
```

```python
# lpid = dunder_version
__version__ = "v201901.0001-alpha"
```


### Code Conventions

Across the implementation of LitProg there are commonly used aliases for imported modules. the `from x import y`

In general, the plain `import x` or `import longlib as ll` imports are preferred over `from x import y` so that usage code always includes the context from where they came.

```python
# lpid = common_imports
import typing as typ
import pathlib2 as pl

InputPaths = typ.Sequence[str]
Paths = typ.Iterable[pl.Path]
```


### CLI command `litprog`

The main module that will have our entry point is `__main__.py`. The next few blocks are mostly boilerplate and the actual code of the command starts with the [`litprog build` sub-command](#cli-sub-command-litprog-build).

The first line of the `__main__.py` file will be a `#!`/shebang. In most cases, when installing with `pip install litprog` the top level script is a (platform dependent) file generated from the [`entry_points`][setup_py_entry_points] declared in `setup.py`. In other words, this line is mostly symbolic and indicates that this is a top level cli script. 

```python
# lpid = shebang_python
#!/usr/bin/env python
```

Each module has a module level logger named `log`.

```python
# lpid = cli_logger
import logging

log = logging.getLogger("litprog.cli")
```

This is a good starting point for tests. Just as a sanity check, let's see if we can import and access the `log` logger.

```yaml
lpid: cli_tests
lptype : session
command: /usr/bin/env python
```

```python
# lpid = cli_tests
import os
import sys
print(os.getcwd())
print("python:", sys.executable)
import tmp__main__ as main
print(main.log.name)
assert main.log.name == 'litprog.cli'
assert False
```

We use the standard python logging module, which is initialized by click using the `--verbose`/`--quiet` options. This helper function should be invoked by each sub-command of litprog.

```python
# lpid = logging_setup
def _configure_logging(verbosity: int = 0) -> None:
    if verbosity >= 2:
        log_format = (
            "%(asctime)s.%(msecs)03d %(levelname)-7s " +
            "%(name)-15s - %(message)s"
        )
        log_level  = logging.DEBUG
    elif verbosity == 2:
        log_format = "%(levelname)-7s - %(message)s"
        log_level  = logging.INFO
    else:
        log_format = "%(levelname)-7s - %(message)s"
        log_level  = logging.WARNING

    logging.basicConfig(
        level=log_level,
        format=log_format,
        datefmt="%Y-%m-%dT%H:%M:%S",
    )
```



We'll be using the venerable [click][click_lib_ref] library to implement our CLI.

```python
# lpid = click_boilerplate
import click
```

In the course of compiling LitProg to universal python using `lib3to6` the
`from __future__ import unicode_literals` import is added to each python
file. Click complains about this for some reason that I haven't dug into
yet: https://click.palletsprojects.com/en/5.x/python3/

As far as I can tell, everything is behaving as expected, so I've added `click.disable_unicode_literals_warning = True`. It would be particularly interesting to test this with non ascii filenames and parameters.

```python
# lpid = click_boilerplate
click.disable_unicode_literals_warning = True
```

We could implement `litprog` as one command atm. but in anticipation of future subcommands we'll use the `click.group` approach to implement git style cli with subcommands.

```python
# lpid = click_boilerplate
@click.group()
@click.version_option(version="v201901.0001-alpha")
@click.option(
    '-v',
    '--verbose',
    count=True,
    help="Control log level. -vv for debug level.",
)
def cli(verbose: int = 0) -> None:
    """litprog cli."""
    _configure_logging(verbose=verbose)
```

Note that version strings may appear to be hard-coded, but they are in fact programatically updated before a release using `make bump_version` or `pycalver bump`.


### CLI sub-command `litprog build`

The `litprog build` subcommand recursively scans the `input_paths` argument for markdown files (with the `.md` extension), from which it builds the various outputs. 

```python
# lpid = litprog_build_subcommand
InputPaths = typ.Sequence[str]

@cli.command()
@click.argument('input_paths', nargs=-1, type=click.Path(exists=True))
@click.option(
    '-v',
    '--verbose',
    count=True,
    help="Control log level. -vv for debug level.",
)
def build(input_paths: InputPaths, verbose: int = 0) -> None:
    _configure_logging(verbose)
    context = _prepare_context(input_paths)
    _build(context)
```


### File-System Helpers

As a first step, we want to simply read in the markdown files by invoking `litprog build lit/` with a directory as an argument.

```python
# lpid = fs_helpers
MarkdownPaths = typ.Iterable[pl.Path]

def _iter_markdown_filepaths(input_paths: InputPaths) -> MarkdownPaths:
    for in_path_str in input_paths:
        in_path = pl.Path(in_path_str)
        if in_path.is_dir():
            for in_filepath in in_path.glob("**/*.md"):
                yield in_filepath
        else:
            yield in_path
```

## Glossary

- [Input] Source Files: Markdown based inputs
- [Output] Code Files: An artifact generated from fenced code blocks
- [Output] Documents: HTML or PDF files

## The Goal

There are various levels at which the reader of a literate program will want to understand it, but each of them should trust that the fact that they are viewing a document meands that it conceptually coherent. This is to say, that if the document contains assertions about how it works, then the existence of the document is a testament to the fact that these assertions are true.

If the following code were to fail, the output document would have programatically generatiod visual indication that this was the case.

```yaml
lpid   : demo
lptype : session
command: /usr/bin/env python
timeout: 1
echo   : False     # output
term   : True
expected_exit_code: 0
```

```python
# lpid = demo
assert True
```

```python
# lpid = demo
# This code block inherits the LitProg declarations of
# the previous block. In this case it is a continuation of the previous
# "validation" session.

assert False          # The captured output should be an error
```

In order to make integration with existing tools easy and so that LitProg is language agnostic, the macro and plugin system works strictly with text, and does not do any ast/parsing of code blocks. The exception to this is LitProg metadata in the form of code block options.

- `litprog` declarations for code blocks use language specific comment syntax.
  In other words, a LitProg declaration in a python code block the first line
  would start with `# litprog` and in a c++ code block the code the first line
  would start with `// litprog`. This choice was made


## The LitProg command

Our initial goal is to generate the `src/litprog/__main__.py` file, which is the main entry point for the `litprog` command. This command is available after running `pip install litprog`.

This build declaration will generate the file. The `inputs` are references to other sections in this markdown file.

```yaml
lptype: out_file
# NOTE: added 'tmp' prefix only until we're satisfied that it works
filepath : "src/litprog/tmp__main__.py"
is_executable : true
inputs : [
    "shebang_python",
    "license_header_boilerplate",
    "common_imports",
    "__main__imports",
    "backtrace_boilerplate",
    "cli_logger",
    "logging_setup",
    "click_boilerplate",
    "litprog_build_subcommand",
    "fs_helpers",
]
```


Some notes library choices:

- `toml`: In additon to json, the toml format is supported to define
  litprog metadata.
- `pathlib2` provides a uniform api for both python2 and python3.

```python
# lpid = __main__imports
import yaml
import toml
import json
import uuid
import collections

```

The [`backtrace`](https://github.com/nir0s/backtrace) package produces
human friendly tracebacks, but is not a requirement to use litprog. To enable it, run
`echo "export ENABLE_BACKTRACE=1;" >> ~/.bashrc`

```python
# lpid = backtrace_boilerplate
# To enable pretty tracebacks:
#   echo "export ENABLE_BACKTRACE=1;" >> ~/.bashrc
if os.environ.get('ENABLE_BACKTRACE') == '1':
    import backtrace

    backtrace.hook(align=True, strip_path=True, enable_on_envvar_only=True)
```


## Compile/Build Phases

Some of the considerations that go into what the phases of the compiler do
are

- Plugins/Libraries that do pre- or post-processing and are only referenced.
  Some plugins might be, spell checker, readability score generator, and
  linters.
- We want to be able to integrate code formatters, in other words feed the
  output of a command which takes a fenced code block as input and feeds it
  back into the initial fenced code block.
- To reduce boilerplate, we want to have macros. But other than for
  demonstration of what the macro does, we don't want the code generated by
  them to be in the pdf files (maybe in the html files, but only if it is
  hidden by default).
- LitProg is a build system and the declaration of output files should allow
  for caching/reuse of build artifacts. TODO: investigate `redo` which is
  supposidly a nicer version of `make`.

To produce a program

 0. Run macro definition code blocks.
 1. Run macros to produce intermediate markdown.
 2. Compile code artifacts to tmp directory.
 3. Run interactive sessions and capture outputs.
 4. Produce code artifacts.
 5. Produce intermediate html artifacts from original markdown.
 6. Extend intermediate html artifacts with captured outputs.
 7. Extend intermediate html by running plugins, for example to add anchor tags that enable jump to definition.
 8. Produce pdf artifacts from html.


### Package Metadata


```yaml
lptype: out_file
lpid: setup_py
filepath : "tmp_setup.py"
inputs : [
  "license_header_boilerplate",
]
```


[click_lib_ref]: https://click.palletsprojects.com

[^1]: Foobar baz buz

[^languages_caveat]: Any language as long as its code is stored in text based files. This is almost all languages, but LitProg won't work with something like scratch.
