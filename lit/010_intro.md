## Sentimentality

    The saying goes: "By their fruits ye shall know them.", not
    "By their words ye shall know them.". Actions speek louder
    than words.

Humans are sentimental creatures. I want to write good software,
and I know this is not an obvious way to make money, certainly
not in the short term. But I do want to have pride in my work and
a sense of accomplishment. Part of that sense of accomplishment
is to have a physical artifact that can be understood and
appreciated by as wide of an audience as possible, perhaps even
by people in my social circles that are not programmers.

I hope that forgoing short term benefits of hacking together
something that works just good enough, will pay off in the long
term. I hope that people who can see and understand and
appreciate my work will see and feel the value of treating
programming as a wonderful mix of the arts of engineering,
mathematics and writing.


## Introduction to `litprog`

    "The craft of programming begins, not with formatting or
    languages or tools or algorithms or data structures; the
    craft of programming begins with empathy."
                                - Kent Beck (paraphrased)

    "Any fool can write code that a computer can understand.
    Good programmers write code that humans can understand."
                                - Martin Fowler


I have spent most of my programming carreer as the sole or main
developer of the software I've developed. As I look to the
future, with the prospect of writing software that more people
have to understand, I know that I must change my ways. In the
past I could keep a whole system in my head and junior
programmers had a difficult time wrapping their heads around the
software I wrote. The software I wrote was full of implicit and
undocumented conventions, known only to me. Writing documentation
has seldom been an integral part of my development workflow, only
recently have I tentatively started doing readme driven
development.

I realize that I must change my ways and I feel that I am not
alone. I want to write software that is of high quality, and code
which is more accessible to other programmers. As a starting
point on this journey, I've decided experiment with literate
programming and vowed to not write any software that involves
networking or threading until I have demonstrated (at least to
myself), that it is possible to write more simple systems that
can be understood, used, maintained and extended by other
developers.


`litprog` parses markdown and generates outputs in these
formats:

 1. `src`: Source code files, from code blocks
 2. `doc`: Static HTML files
 3. `pdf`: PDF files (in A4, Letter, Booklet)

It supports the following markdown extensions

 - Footnotes
 - Paragraph with css class or html node type (admonitions, asside)
 - Diagrams using aafigure
 - Tables
 - Syntax Highlighting using pygments
 - Hyperlinked Source Code (where possible)
 - Math support somehow using MathJax


### Use Cases

`litprog` is primarilly intended for technical documentation and
high quality source code. It can be used in an existing code base
to generate a subset of its files, while leaving others alone.
You can start out writing a quick and dirty prototype and start
using `litprog` once you've proven your idea.


### Default Fonts

The output generated by `litprog` uses some customizable defaults
fonts:

 - `body {font: Tinos,"Times New Roman",serif;}`
 - `code {font: Monoid,monospace;}`

Documents generated by `litprog` look readable, even beautiful
both on the web and on print. Tinos is chosen because it is a
readable serif font, with a metric compatible fallback font
"Times New Roman" which is widely installed. This choise
minimizes the jarring reflow of a html after the font has
finished loading. While Monoid is not widely installed, it is a
good choice in particular because of the uniqueness of each
individual character. A great deal of confusion in programming
can be avoided if each character in a source code text can be
clearely distinguished from other characters and even be
unambigously identified as a certain character by itself. In
particular the zero character `"0"` should have a strike through,
to distinguish it from an upper case `"O"`; the upper case `"I"`
and lower case `"l"` should have serifs, the digit `"1"` and the
pipe character `"|"` should not. These are the most important
considerations


### Typography Defaults

The perhaps most noteworthy choice in output generated by
`litprog` is the use of *justified and hyphenated body text*.
This may be just a matter of taste, but one could argue that
typographers are correct to regard a block of text with ragged
edges on the right to be ugly.

Dsylexia does not just affect some people, it can affect
everybody if the text suffers from bad typesetting. The most
important metric here is the ratio of line length to line height.
A line height of 1.5em allows the eyes of a reader to scan across
a line and stay on track. As the line gets longer, the more line
height would is required to ensure that the eye can find the next
line as it moves back across the page. The better choice however
is to limit the length of the line.

 - Minimum of 50 characters per line
 - Maximum of 85 characters per line
 - Minimum line height 1.4em
 - Maximum line height 1.8em

On an A4 and Letter page, a single column layout would require
quite a large font size even on an 85 character long line, so the
default is to use a two column layout.

On an A5
page or booklet, a two column layout would with increased line
length is preferrable.

Code blocks are read differently than a flowing block of text.
They have line lengths determined by the program structure, they
are scanned up and down along their indentation and back and
forth from declaractions and assignments of symbols to their
usages. This implies that a smaller line height is permissible.

 - Maximum of 80 characters per line in code blocks
