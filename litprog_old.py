#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""

"""
from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals
import os
import io
import re
import sys
import ast
import subprocess as sp
from collections import namedtuple
import docopt
import pyphen
import pygments
import markdown

# # `code.markdown`

# ## Introduction

# `code.markdown` is a literate programming tool. Source files are
# written in markdown, which contain both documentation and the
# executable source code. The goal is to write high quality
# documentition which also happens to be the implementation of what
# is documented.

# Here is a minimal example of what a file `fib.py.lit` might look
# like:

#     --------------------------------------------------

#     ### Basic Fibonacci Example

#     A function to compute the nth Fibonacci number might be
#     defined as follows:

#     $$ F_n = F_{n-1} + F_{n-2} $$
#     $$ F_0 = 0 $$
#     $$ F_1 = 1 $$

#     A naive implementation in Python might look like this[^1]:

#     [^1]:
#         The infinite sequence can be produced with he following
#         generator function:
        
#         ```
#         def fib():   
#             a, b = 1, 1
#             while True:
#                 yield a
#                 a, b = b, a + b
#         ```

#     ```
#     def fib(n):
#         if n < 2:
#             return n
#         return fib(n - 1) + fib(n - 2)
#     ```

#     Now let's see it in action.

#     {{capture: stdout}}
#     ```
#     for i in range(10):
#         print("fib({}) == {}".format(i, fib(i)))
#     ```

#     --------------------------------------------------

# Here is the html output generated by the above code
# (delimited by the horizontal rules):

# --------------------------------------------------

# ### Basic Fibonacci Example

# A function to compute the nth Fibonacci number might be
# defined as follows:

# $$ F_n = F_{n-1} + F_{n-2} $$
# $$ F_0 = 0 $$
# $$ F_1 = 1 $$

# A naive implementation in Python might look like this[^1]:

# [^1]:
#     The infinite sequence can be produced with he following
#     generator function:
    
#     ```
#     def fib():   
#         a, b = 1, 1
#         while True:
#             yield a
#             a, b = b, a + b
#     ```

def fib(n):
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)

# Now let's see it in action.

import os
import io
import sys

if os.getenv('CODE_DOT_MD_CAPURE'):
    _orig_stdout = sys.stdout
    _capture_out = io.StringIO()
    sys.stdout = _capture_out

    for i in range(10):
        print("fib({}) == {}".format(i, fib(i)))
    
    sys.stdout = _orig_stdout
    _CAPTURED_OUT = _capture_out.getvalue()
    fh = io.open('C:\\Users\\Manuel\\lit_test.txt', mode='w')
    fh.write(_CAPTURED_OUT)

# --------------------------------------------------

# ## Format

# Metadata can be associated with each section of the markdow file,
# which gives you control over how the target formats are generated.
# Take a look at the generated [fib.py.html](fib.py.html). You can see,
# that the output of a fenced section is be captured and a new section
# is generated.

# We hope to make it as easy as possible to write the high quality
# documentation.


# ## Documentation vs Code

# Code describes what happens and documentation should describe why
# it happens.

# ## Motivation - Literate Programming

# > [Let us change our attitude to programming: We should not focus
# > on telling a computer what to do, rather we should focus on
# > explaining to humans what we want a computer to do.]
# >
# >  — Donald Knuth paraphrased from
# > [
# >   "Literate Programming (1984)" CSLI, 1992, pg. 99
# > ](http://www.literateprogramming.com/lpquotes.html).

# Sounds good doesn't it. It sounds even better when you want to fix a
# bug in an existing program that somebody else wrote. Or maybe you
# wrote the code a while ago and now you have no idea why you wrote it
# the way you did. So besides cursing developers that came before us,
# what can we do to improve this situation? One suggestion

# So if literate programming is such a great idea, why isn't it more
# widespread in industry? It has had some success in programming
# literature and academia, where exposition to humans is more important,
# so lets listen to what one practitioner had to say about his
# experience:


# > It turned out to be much more difficult to produce a literate
# > program than producing either a piece of literature or a program
# > alone. It is easier to write only a book, because the author can
# > easily decrease the level of detail in the exposition and resort to
# > a more superficial description whenever desired. It is easier to
# > write only a program, because the programmer can settle for correct
# > and efficient code even if it is hard to understand. None of this is
# > possible in literate programming. I found myself very often
# > rewriting a correct and efficient piece of code just because I did
# > not manage to explain it very well. And I had to think hard about
# > extracting the interesting ideas from repetitive tasks, resorting to
# > code and table generation instead of simple programming. On the
# > positive side, while both activities — writing and programming —
# > become harder, the quality increases too. Programs become more
# > efficient, more reliable, and more readable; the documentation
# > becomes comprehensive, detailed, and may be even enjoyable.
# >
# >  — Martin Ruckert from "Understanding MP3 (2005)", pg. v

# In other words, we shouldn't kid ourselves. This is more work. What
# we need to judge is, whether or not that work will pay off.

# I find, that I am much more thoughtful about how I write code, if I
# expect it to receive even the slightest bit of review. An experienced
# collegue who doesn't know the particular programming language you are
# using, may still be able to provide useful feedback in a code review
# of a literate program.

# Exploration of ideas.

# Well, lets look at one of the more popular literate programming tools:

#  documentation becomes outdated
#  yagni

# Anoter problem is that even in semi-popular literate programming
# tools, the documentation is often still treated as a second class
# citizen.

# There are many barriers to the adoption of a programming tool.

#  1. How hard is it to install?
#  2. If you get it set up, how hard is it to learn?
#  3. If you have learned it, how much friction does it add
#     to development?
#  4. Is all that effort even worth it?

# > [...a programmer, who wants to provide the best possible
# > documentation, needs two things: a language for formatting, and a
# > language for programming. Neither by itself can provide the best
# > documentation; but when both languages are combined, we obtain a
# > system that is much more useful than either separately.]
# >
# >  — Donald Knuth paraphrased from
# > [
# >   "Literate Programming (1984)" CSLI, 1992, pg. 99
# > ](http://www.literateprogramming.com/lpquotes.html).

# > [Docco is a quick-and-dirty documentation generator... It produces
# > an HTML document that displays your comments intermingled with your
# > code.]
# >
# > — Jeremy Ashkenas paraphrased from https://jashkenas.github.io/docco/

# Disadvantages of documentation in code

#  - Output of the code (documentation is ancillary)
#  - Output for the web (code is ancillary)
#  - Typography and Readability (aka what docco got right)
#     - Max Width
#     - Contrast, i.e. Black on White
#     - Hyphenation and Justification
#     - Font Size
#     - Code Monospaced and max line length
#     - Linking
#     - use same link schema as standardlib where possible
#       https://docs.python.org/3/library/collections.html#collections.namedtuple


# ## Toward a Culture of Quality and Craftsmanship

# The larger a system, the more components it is composed of, the higher
# the likelyhood that any one of them will fail and bring the system to
# a halt. After a long session of debugging (especially when dealing
# with a concurrency issue), I am often amazed that any of these
# computer things ever work at all. I gain a new appreciation for how
# incredibly fragile these systems can be and how much time we end up
# wasting by hot fixing, rebooting and recovering, all in an effort to
# keep

# The more we have to explain our work to others, the more likely we
# are be embarresed at cutting corners. The more others see and read
# our work, the more likely errors and bad practices are to be
# corrected. Imagine how comfortable passengers would be, getting on
# a plane. Even for the best of us, code is often cryptic and for the
# average user hidden from plain sight.

# Let us take look at common perceptions of cultures. At least in my
# mind,
# These may be generalizations, but they have a real effect. I think
# by now, managers will think twice about outsourcing software
# development to India. When high enough a price has been payed,
# when enough projects have failed, the old truth reasserts itself:
# You get what you pay for.
# Good workmanship can be recognized in different cultures. German
# engineering vs
# The results we have seen by outsourcing to
# The less we think of the next deadline and the more we think of
# ourselves a few years down the road, the


# ## Virtues for Programming

# Ownership
# Dilligence/Humillity
# Frugality/Efficiency


# ## Metadata

# The order in which you would like to present code to a human may be
# different than the order required by a computer. For example, a human
# might like to read a high level overview of an algorithm and only
# subsequently go into its details. However a programming language may
# require all the dependencies of an algorithm to be declared before
# their usage.


# ## Boilerplate


# test is for from


# ## CLI --help Message


# ## Standard Lib Imports


# ## External Package Imports
# Pyphen is a lybrary to hyphenate words.


# ## Constants

# background                white
# keywords                  red         #905
# constants                 black
# braces                    black
# variables                 black
# strings                   blue        #029
# escape sequences          purple
# function declarations     green
# parameters                orange      #B40
# builtins                  blue        #08B
# operators                 red         #B00
# numbers/bools/None        purple
# comments                  gray


DEBUG = False

Section = namedtuple('Section', [
    'index', 'type', 'meta', 'lines'
])


def py_comment(lines):
    for line in lines:
        if line.strip():
            yield "# " + line
        else:
            yield line


def js_comment(lines):
    for line in lines:
        if line.strip():
            yield "// " + line
        else:
            yield line


def indent(content):
    # TODO (mbarkhau 2016-08-29): detect line endings
    # TODO (mbarkhau 2016-08-29): detect tab indent
    line_ending = "\n"
    indent = "    "
    return line_ending.join((
        indent + line
        for line in content.split(line_ending)
    ))


def py_capture_stdout(text, capture):
    text = (
        "import os\n"
        "import io\n"
        "import sys\n"
        "\n"
        "if os.getenv('CODE_DOT_MD_CAPURE'):\n"
        "    _orig_stdout = sys.stdout\n"
        "    _capture_out = io.StringIO()\n"
        "    sys.stdout = _capture_out\n"
        "\n"
    ) + indent(text) + (
        "\n"
        "    sys.stdout = _orig_stdout\n"
        "    _CAPTURED_OUT = _capture_out.getvalue()\n"
        "    fh = io.open('C:\\\\Users\\\\Manuel\\\\lit_test.txt', mode='w')\n"
        "    fh.write(_CAPTURED_OUT)\n"
    )
    return text


PLUGINS = {
    'py': {
        'comment' : py_comment,
        'capture': py_capture_stdout,
    },
    'js': {
        'comment' : js_comment,
        'capture': (lambda text, capture: text),
    }
}

# TODO (mbarkhau 2016-08-21): Warn about line length in
#       code blocks, because they cause horizontal
#       scrolling.
# TODO (mbarkhau 2016-08-21): Parse lang from file
#       level metadata

HYPHEN_DICT = pyphen.Pyphen(lang='en_US')


def open(filepath, mode='r', encoding='utf-8'):
    return io.open(filepath, mode=mode, encoding=encoding)


META_PARAM_RE = re.compile(r"""
    (?P<key>[\w\-\.]+)
    \:
    (?P<val>[^\}\,]+)
    (?:\}|\,)
""", re.VERBOSE | re.MULTILINE)


def parse_section_meta(raw_meta):
    meta = {}
    for match in META_PARAM_RE.finditer(raw_meta):
        key, val = match.groups()
        if key in meta:
            if not isinstance(meta[key], list):
                meta[key] = [meta[key]]
            meta[key].append(val)
        else:
            meta[key] = val

    # TODO (mbarkhau 2016-08-23): validate meta
    if raw_meta.strip():
        print(meta)
    return meta


# TODO (mbarkhau 2016-08-17): cleanup global
_section_index = 0


def parse_section(section_type, raw_section_meta, section_lines):
    has_meta = bool(raw_section_meta.strip())
    has_content = bool(section_lines)
    if not (has_content or has_meta):
        return

    global _section_index
    _section_index += 1

    section_meta = parse_section_meta(raw_section_meta)
    return Section(
        _section_index,
        section_type,
        section_meta,
        section_lines
    )


def iter_sections(fh, filepath="<filepath>"):
    # A very simple state machine that switches between
    # four states.
    stype = 'text'     # ('text'|'code'|'data'|'meta')
    smeta = ""
    slines = []
    prev_empty = False

    for i, line in enumerate(fh):
        line_no = i + 1
        illegal_state_err_msg = (
            "Illegal state {} reached on line {} of {}."
            .format(stype, line_no, filepath)
        )
        if DEBUG:
            print(
                "----",
                line_no,
                stype,
                len(smeta),
                len(slines),
                repr(line)
            )

        if line.strip() == "":
            slines.append(line)
            prev_empty = True
            continue

        if line.startswith("{{"):
            if stype not in ('text', 'data'):
                raise RuntimeError(illegal_state_err_msg)

            # Beginning of new metadata implies that the
            # previous section has ended.
            yield parse_section(stype, smeta, slines)

            smeta = line
            slines = []
            if line.rstrip().endswith("}}"):
                # single line metadata
                stype = 'text'
            else:
                # begin of a metadata block
                stype = 'meta'
            continue

        if line.rstrip() == "}}":
            # end of metadata
            smeta += line
            # The next section may or may not be
            # 'text' but that is the default.
            stype = 'text'
            continue

        if stype == 'meta':
            smeta += line
            continue

        if line.rstrip() == "```":
            if stype in ('text', 'data'):
                # begin of a new code block
                if slines:
                    yield parse_section(stype, smeta, slines)
                    smeta = ""
                    slines = []
                stype = 'code'
            elif stype == 'code':
                # end of current code block
                yield parse_section(stype, smeta, slines)

                stype = 'text'
                smeta = ""
                slines = []
            else:
                raise RuntimeError(illegal_state_err_msg)
            prev_empty = False
            continue

        is_indented = (
            line.startswith("    ") or
            line.startswith("\t")
        )

        if stype == 'text' and prev_empty and is_indented:
            # end of text section, begin of data
            if slines:
                yield parse_section(stype, smeta, slines)
            stype = 'data'
            smeta = ""
            slines = [line]
            prev_empty = False
            continue

        if stype == 'data' and line.strip() and not is_indented:
            # end of data block
            yield parse_section(stype, smeta, slines)
            stype = 'text'
            smeta = ""
            slines = [line]
            prev_empty = False
            continue

        # continue existing section
        slines.append(line)

    yield parse_section(stype, smeta, slines)


def iter_lit_paths(paths):
    if not isinstance(paths, list):
        paths = [paths]
    for path in paths:
        if os.path.isfile(path):
            yield path
        elif os.path.isdir(path):
            tree = os.walk(path)
            for dirname, dirnames, filenames in tree:
                for filename in filenames:
                    if filename.endswith('.lit'):
                        yield os.path.join(dirname, filename)
        else:
            print("Invalid path: ", path)


def parse_lit_sections(in_path):
    with open(in_path) as fh:
        return list(iter_sections(fh))


POSITION_TYPES = ['head', 'body', 'foot']


def section_key(section):
    pos = section.meta.get('pos', "body").strip()
    if "-" not in pos:
        pos += "-" + str(section.index)
    pos_type, pos_num = pos.split("-")
    return (POSITION_TYPES.index(pos_type), float(pos_num))


def write_src(sections, out_path):
    sections = sorted(sections, key=section_key)
    extension = out_path.rsplit(".", 1)[-1]
    # TODO (mbarkhau 2016-08-25): allow override via file metadata
    plugin = PLUGINS[extension]
    with open(out_path, mode='w') as fh:
        for section in sections:
            if section.type in ('text', 'data'):
                text = "".join(plugin['comment'](section.lines))
                fh.write(text)
            elif section.type == 'code':
                text = "".join(section.lines)
                capture = section.meta.get('capture')
                if capture:
                    text = plugin['capture'](text, capture)
                fh.write(text)


def hyphenate_words(content):
    parts = content.split("`")
    parts_iter = iter(parts)
    part = next(parts_iter, "")
    while part:
        for word in part.split(" "):
            yield HYPHEN_DICT.inserted(word, "&shy;")

        literal = next(parts_iter, "")
        if literal:
            yield "`" + literal + "`"

        part = next(parts_iter, "")


def write_md(sections, out_path):
    # TODO (mbarkhau 2016-08-15): cache hyphenation
    # TODO (mbarkhau 2016-08-14): parse and preserve
    #       line endings
    # TODO (mbarkhau 2016-08-21): set flavour based on metadata
    # TODO (mbarkhau 2016-08-14): syntax highlite for code
    with open(out_path, mode='w') as fh:
        for section in sections:
            if section.type == 'text':
                content = "".join(section.lines)
                fh.write(" ".join(hyphenate_words(content)))
            elif section.type == 'data':
                fh.write("".join(section.lines))
            elif section.type == 'code':
                fh.write(
                    "```\n:::python\n" +
                    "".join(section.lines) +
                    "```\n"
                )

def mtime(path):
    if not os.path.exists(path):
        return 0
    return os.stat(path).st_mtime



def main(args):
    # TODO (mbarkhau 2016-08-19): parse arguments
    paths = args or [
        "C:\\Users\\Manuel\\Dropbox\\software_projects\\umemo"
    ]
    verbose = True
    output_format = 'html'

    for lit_in_path in iter_lit_paths(paths):
        dir_path = os.path.dirname(lit_in_path)
        src_out_path = lit_in_path[:-4]
        md_out_path = lit_in_path[:-4] + ".md"
        html_out_path = lit_in_path[:-4] + "." + output_format
        tmpl_path = os.path.join(dir_path, "template.html")

        lit_mtime = mtime(lit_in_path)
        src_mtime = mtime(src_out_path)
        md_mtime = mtime(md_out_path)
        html_mtime = mtime(html_out_path)
        tmpl_mtime = mtime(tmpl_path)

        lit_changed = (
            lit_mtime > src_mtime or
            lit_mtime > md_mtime
        )
        tmpl_changed = tmpl_mtime > html_mtime

        if not (lit_changed or tmpl_changed):
            if verbose:
                print("unchanged ", lit_in_path)
            continue

        if verbose:
            print("updated   ", lit_in_path)

        sections = parse_lit_sections(lit_in_path)

        # To simplify things in the iterator we allow empty sections
        # to be emitted for now, which we filter out here.
        sections = [s for s in sections if s]

        if lit_changed:
            if verbose:
                print("refreshing", src_out_path)
            write_src(sections, src_out_path)

            env = os.environ.copy()
            env['CODE_DOT_MD_CAPURE'] = "1"
            sp.Popen(['python', '-c', 'import lit'], env=env)
        # TODO (mbarkhau 2016-08-14): run and capture output

        if lit_changed:
            if verbose:
                print("refreshing", md_out_path)
            write_md(sections, md_out_path)

        if lit_changed or tmpl_changed:
            if verbose:
                print("refreshing", html_out_path)

            md_data = open(md_out_path).read()
            html_data = markdown.markdown(md_data, extensions=[
                'markdown.extensions.extra',
                'markdown.extensions.codehilite',
                'markdown.extensions.footnotes',
            ])

            with open(tmpl_path) as fh:
                tmpl_data = fh.read()
            # TODO (mbarkhau 2016-08-22): parse template
            #           as jinja2.
            # TODO (mbarkhau 2016-08-22): generate
            #           - authors
            #           - language
            #           - title
            #           - date
            with open(html_out_path, mode='w') as fh:
                fh.write(tmpl_data.replace("$body$", html_data))
            # args = [PANDOC_CMD]
            # sp.call([
            #     PANDOC_CMD,
            #     '--from', 'markdown',
            #     '--to', output_format,
            #     '--standalone',
            #     '--output', html_out_path,
            #     '--template', tmpl_path,
            #     md_out_path
            # ])
if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
